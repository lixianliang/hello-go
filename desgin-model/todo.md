# 设计模式


## 设计模式
    包含c++ go 
    https://refactoringguru.cn/design-patterns/decorator/go/example#example-0

## 工作那么久，才知道的 SOLID 设计原则
    https://segmentfault.com/a/1190000023114300

## 工作那么久，才知道的 SOLID 设计原则
    https://segmentfault.com/a/1190000023114300

    单一职责
    开放/封闭
    里式替换
    接口隔离
    依赖倒置

### 单一职责
    单一职责原则用于控制类的粒度大小，减少类中不相关功能的代码耦合，使得类更加的健壮；另外单一职责原则也适用于模块之间解耦，对于模块的功能划分有很大的指导意义

1. 相关设计模式
    面对违背单一职责原则的程序代码，我们可以利用外观模式，代理模式，桥接模式，适配器模式，命令模式对已有的设计进行重构，实现多职责的分离

### 开闭原则
    软件中的对象（类，模块，函数）应该对于扩展是开放的，但对于修改是封闭的；这里对扩展开发表示添加新的代码，就可以让程序行为扩展来满足需求的变化；对修改封闭表示在扩展程序行为时不要修改已有的代码，进而避免
影响原有的功能

1. 相关设计模式
    面对违背开闭原则，可以用工厂模式，观察者模式，模板模式，策略模式，组合模式使相关设计模式的关键点就是识别出最有可能变化和扩展的部分，然后构造抽象来隔离这些变化

1. 小结
    面向需求的变化就能进行快速的调整实现功能，这大大提高系统的灵活性，可重用性和可维护性，但会增加一定的复杂性

### 里式替换原则
    在不影响程序正确性的基础上，所有使用基类的地方都能使用其子类的对象来替换

1. 小结
    要让程序代码符合里式替换原则，需要保证子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法，换句话就是子类可以扩展父类的功能，但不能改变父类原有的功能

### 接口隔离原则
    客户端不应该依赖那些它不需要的接口。客户端应该只依赖它实际使用的方法，因为如果一个接口具备了若干个方法，那就意味着它的实现类都要实现所有接口方法，从代码结构上就十分臃肿

1. 小结
    接口隔离原则主要功能就是控制接口的粒度大小，防止暴露给客户端无相关的代码和方法，保证了接口的高内聚，降低与客户端的耦合

### 依赖倒置原则
    高层模块不应该依赖低层模块，应该共同依赖抽象
    抽象不应该依赖细节，细节应该依赖抽象
    这里的抽象就是接口和抽象类，而细节就是实现接口或继承抽象类而产生的类

1. 相关设计模式
    关于依赖倒置原则，可以用到的设计模式有工厂模式，模板方法模式，策略模式

1. 小结
    依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性

## 单例模式
    singleton.go

## 工厂模式
    factory.go

## 代理模式
    proxy.go

## 装饰器
    decorator.go

### Go 设计模式之装饰器模式
    https://learnku.com/articles/26820

    装饰器的主要目的就是对基础对象扩展功能，虽然在一定程度上保持了扩展性，但是如果过度使用会出现众多小的对象，会是程序变得复杂
    装饰器是一种设计模式，应用场景就是为某个已存在的功能模块(类或者函数)添加一些功能(装饰)，而不会侵入和修改原有的功能模块


    装饰器模式和代理模式类似
    装饰器扩展和基础对象相关的功能；代理扩展和基础对象不太相关内容

### Go 函数式编程篇（四）：通过高阶函数实现装饰器模式
    https://geekr.dev/posts/go-decorator-implement-by-high-order-function
    函数式装饰器
    将匿名函数作为函数参数和将匿名函数作为函数返回值 

## 适配器
    adapter.go

## 门面模式
    facade.go

## 组合模式
    composite.go

## 享元模式
    flyweight.go


## 观察者模式
    observer.go

## 模板模式
    template.go

## 策略模式

## 职责模式
    chain.go

## 状态模式
